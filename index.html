<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Â∑•‰ΩúÊµÅÁªòÂà∂</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
        }
        body {
            margin: 0;
            height: 100vh;
            overflow: hidden;
            background: #1e1e2f;
        }
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .toolbar {
            height: 50px;
            background: #2d2d3f;
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 12px;
            border-bottom: 1px solid #3a3a4f;
            color: #ddd;
        }
        .toolbar button {
            background: #3d3d55;
            border: none;
            color: white;
            padding: 6px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: 0.1s;
            border: 1px solid #5a5a77;
        }
        .toolbar button:hover {
            background: #5d5d7a;
        }
        .toolbar span {
            flex: 1;
        }
        .separator {
            width: 1px;
            height: 24px;
            background: #4a4a63;
            margin: 0 8px;
        }
        .save-dropdown-container {
            position: relative;
            display: inline-block;
        }
        #btn-save-main {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
            border-right: 1px solid #5a5a77;
        }
        #btn-save-dropdown {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            padding-left: 8px;
            padding-right: 8px;
            margin-left: -1px;
        }
        .save-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: #2d2d3f;
            border: 1px solid #5a5a77;
            border-radius: 6px;
            margin-top: 4px;
            min-width: 140px;
            z-index: 20;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        .save-menu div {
            padding: 10px 16px;
            cursor: pointer;
            color: white;
            font-size: 14px;
            transition: background 0.1s;
        }
        .save-menu div:hover {
            background: #4a4a6a;
        }
        .save-menu div:first-child {
            border-top-left-radius: 6px;
            border-top-right-radius: 6px;
        }
        .save-menu div:last-child {
            border-bottom-left-radius: 6px;
            border-bottom-right-radius: 6px;
        }
        .main {
            display: flex;
            flex: 1;
            min-height: 0;
            position: relative;
        }
        .node-palette {
            width: 250px;
            background: #262635;
            border-right: 1px solid #3a3a4f;
            display: flex;
            flex-direction: column;
            color: #eee;
        }
        .panel-header {
            padding: 14px 16px;
            font-weight: 600;
            border-bottom: 1px solid #3a3a4f;
            background: #2a2a3c;
        }
        .node-list {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
        }
        .node-item {
            background: #323248;
            border: 1px solid #51516e;
            border-radius: 8px;
            padding: 12px 10px;
            text-align: center;
            cursor: grab;
            transition: 0.1s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            font-size: 15px;
            font-weight: 500;
        }
        .node-item:hover {
            background: #3f3f5a;
            border-color: #7a7aac;
        }
        .node-item:active {
            cursor: grabbing;
        }
        .canvas-container {
            flex: 1;
            background: #1a1a28;
            position: relative;
            overflow: hidden;
            min-width: 0;
            width: 100%;
        }
        #workflowCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #1e1e2f;
            cursor: default;
        }
        .property-panel {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 300px;
            background: #262635;
            border-left: 1px solid #3a3a4f;
            display: flex;
            flex-direction: column;
            color: #eee;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 10;
            box-shadow: -2px 0 10px rgba(0,0,0,0.3);
        }
        
        .property-panel.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        .property-content {
            padding: 20px 16px;
            overflow-y: auto;
        }
        .property-field {
            margin-bottom: 18px;
        }
        .property-field label {
            display: block;
            font-size: 13px;
            color: #aaa;
            margin-bottom: 6px;
        }
        .property-field input, .property-field textarea {
            width: 100%;
            background: #1a1a28;
            border: 1px solid #4a4a65;
            color: white;
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 14px;
        }
        .no-selection {
            color: #888;
            font-style: italic;
            padding: 20px 0;
            text-align: center;
        }
        .port-hint {
            font-size: 12px;
            color: #9a9ac0;
            margin-top: 20px;
            border-top: 1px solid #3a3a4f;
            padding-top: 16px;
        }
    </style>
</head>
<body>
<div id="app">
    <div class="toolbar">
        <button id="btn-new">üìÑ Êñ∞Âª∫</button>
        <button id="btn-open">üìÇ ÊâìÂºÄ</button>
        <div class="save-dropdown-container">
            <button id="btn-save-main">üíæ ‰øùÂ≠ò</button>
            <button id="btn-save-dropdown">‚ñº</button>
            <div id="save-menu" class="save-menu">
                <div id="btn-save-json">‰øùÂ≠ò‰∏∫ JSON</div>
                <div id="btn-save-svg">‰øùÂ≠ò‰∏∫ SVG</div>
            </div>
        </div>
        <span class="separator"></span>
        <button id="btn-undo">‚Ü© Êí§ÈîÄ</button>
        <button id="btn-redo">‚Ü™ ÈáçÂÅö</button>
        <span class="separator"></span>
        <button id="btn-fit">üîç ÈÄÇÂ∫îËßÜÂõæ</button>
    </div>

    <div class="main">
        <div class="node-palette">
            <div class="panel-header">üì¶ ËäÇÁÇπÂ∫ì</div>
            <div class="node-list" id="node-palette-list">
                <div class="node-item" draggable="true" data-type="start" data-label="üöÄ ÂºÄÂßãËäÇÁÇπ">üöÄ ÂºÄÂßãËäÇÁÇπ</div>
                <div class="node-item" draggable="true" data-type="process" data-label="‚öôÔ∏è Â§ÑÁêÜËäÇÁÇπ">‚öôÔ∏è Â§ÑÁêÜËäÇÁÇπ</div>
                <div class="node-item" draggable="true" data-type="end" data-label="üèÅ ÁªìÊùüËäÇÁÇπ">üèÅ ÁªìÊùüËäÇÁÇπ</div>
                <div class="node-item" draggable="true" data-type="condition" data-label="üîÄ Êù°‰ª∂ÂàÜÊîØ">üîÄ Êù°‰ª∂ÂàÜÊîØ</div>
                <div class="node-item" draggable="true" data-type="merge" data-label="üß© ÂêàÂπ∂ËäÇÁÇπ">üß© ÂêàÂπ∂ËäÇÁÇπ</div>
            </div>
        </div>

        <div class="canvas-container" id="canvas-container">
            <canvas id="workflowCanvas"></canvas>
        </div>

        <div class="property-panel">
            <div class="panel-header">üìã ËäÇÁÇπÂ±ûÊÄß</div>
            <div class="property-content" id="property-panel">
                <div class="no-selection">ËØ∑ÈÄâÊã©‰∏Ä‰∏™ËäÇÁÇπ</div>
            </div>
        </div>
    </div>
</div>

<script>
    (function() {
        let nodes = [];
        let edges = [];
        let selectedNode = null;
        let selectedEdge = null;
        let nextNodeId = 1000;
        let nextEdgeId = 5000;

        let transform = {
            offsetX: 100,
            offsetY: 80,
            scale: 1.0
        };

        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let dragNodeId = null;
        let resizeNodeId = null;
        let resizeStart = { width: 0, height: 0, mouseX: 0, mouseY: 0 };
        let dragOffsetX = 0, dragOffsetY = 0;

        let isConnecting = false;
        let connectionStart = null;
        let connectionMouseX = 0, connectionMouseY = 0;

        let historyStack = [];
        let historyIndex = -1;

        const canvas = document.getElementById('workflowCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const palette = document.getElementById('node-palette-list');
        const propertyDiv = document.getElementById('property-panel');

        const nodeTypeDefinitions = {
            start: { 
                title: 'ÂºÄÂßãËäÇÁÇπ',
                inputs: [],
                outputs: [{ name: 'out', type: 'any' }],
                color: '#3b5e3b'
            },
            process: {
                title: 'Â§ÑÁêÜËäÇÁÇπ',
                inputs: [{ name: 'in', type: 'any' }],
                outputs: [{ name: 'out', type: 'any' }],
                color: '#3f5f7a'
            },
            end: {
                title: 'ÁªìÊùüËäÇÁÇπ',
                inputs: [{ name: 'in', type: 'any' }],
                outputs: [],
                color: '#7a4f4f'
            },
            condition: {
                title: 'Êù°‰ª∂ÂàÜÊîØ',
                inputs: [{ name: 'in', type: 'any' }],
                outputs: [{ name: 'true', type: 'any' }, { name: 'false', type: 'any' }],
                color: '#9b6b43'
            },
            merge: {
                title: 'ÂêàÂπ∂ËäÇÁÇπ',
                inputs: [{ name: 'in1', type: 'any' }, { name: 'in2', type: 'any' }],
                outputs: [{ name: 'out', type: 'any' }],
                color: '#5f4f6f'
            }
        };

        function generateNodeId() { return nextNodeId++; }
        function generateEdgeId() { return nextEdgeId++; }

        function pushHistory() {
            historyStack = historyStack.slice(0, historyIndex + 1);
            const snapshot = {
                nodes: JSON.parse(JSON.stringify(nodes)),
                edges: JSON.parse(JSON.stringify(edges))
            };
            historyStack.push(snapshot);
            historyIndex = historyStack.length - 1;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                const snap = historyStack[historyIndex];
                nodes = JSON.parse(JSON.stringify(snap.nodes));
                edges = JSON.parse(JSON.stringify(snap.edges));
                selectedNode = null;
                selectedEdge = null;
                updatePropertyPanel();
                drawCanvas();
            }
        }

        function redo() {
            if (historyIndex < historyStack.length - 1) {
                historyIndex++;
                const snap = historyStack[historyIndex];
                nodes = JSON.parse(JSON.stringify(snap.nodes));
                edges = JSON.parse(JSON.stringify(snap.edges));
                selectedNode = null;
                selectedEdge = null;
                updatePropertyPanel();
                drawCanvas();
            }
        }

        pushHistory();
        
        updatePropertyPanel();
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX - rect.left;
            const clientY = e.clientY - rect.top;
            const canvasX = (clientX - transform.offsetX) / transform.scale;
            const canvasY = (clientY - transform.offsetY) / transform.scale;
            return { x: canvasX, y: canvasY };
        }

        function resizeCanvas() {
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            drawCanvas();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(transform.offsetX, transform.offsetY);
            ctx.scale(transform.scale, transform.scale);

            ctx.strokeStyle = '#33334b';
            ctx.lineWidth = 0.5 / transform.scale;
            const step = 30;
            const startX = -transform.offsetX / transform.scale - 100;
            const startY = -transform.offsetY / transform.scale - 100;
            const endX = startX + (canvas.width / transform.scale) + 200;
            const endY = startY + (canvas.height / transform.scale) + 200;
            ctx.beginPath();
            for (let x = Math.floor(startX / step) * step; x < endX; x += step) {
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
            }
            for (let y = Math.floor(startY / step) * step; y < endY; y += step) {
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
            }
            ctx.strokeStyle = '#2a2a3c';
            ctx.stroke();

            edges.forEach(edge => {
                const sourceNode = nodes.find(n => n.id === edge.sourceNode);
                const targetNode = nodes.find(n => n.id === edge.targetNode);
                if (!sourceNode || !targetNode) return;

                const startPort = getPortPosition(sourceNode, edge.sourcePortIndex, 'output');
                const endPort = getPortPosition(targetNode, edge.targetPortIndex, 'input');

                ctx.beginPath();
                const midX = (startPort.x + endPort.x) / 2;
                ctx.moveTo(startPort.x, startPort.y);
                ctx.bezierCurveTo(midX, startPort.y, midX, endPort.y, endPort.x, endPort.y);
                ctx.lineWidth = 2.5 / transform.scale;
                ctx.strokeStyle = (selectedEdge === edge.id) ? '#ffaa33' : '#9f9fd6';
                ctx.stroke();
            });

            nodes.forEach(node => {
                drawNode(node, node.id === selectedNode);
            });

            if (isConnecting && connectionStart) {
                const startNode = nodes.find(n => n.id === connectionStart.nodeId);
                if (startNode) {
                    const startPos = getPortPosition(startNode, connectionStart.portIndex, 'output');
                    ctx.beginPath();
                    ctx.moveTo(startPos.x, startPos.y);
                    ctx.bezierCurveTo(
                        (startPos.x + connectionMouseX)/2, startPos.y,
                        (startPos.x + connectionMouseX)/2, connectionMouseY,
                        connectionMouseX, connectionMouseY
                    );
                    ctx.strokeStyle = '#ffaa33';
                    ctx.lineWidth = 2 / transform.scale;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            ctx.restore();
        }

        function getPortPosition(node, portIndex, type) {
            const width = node.width || 160;
            const baseY = node.y + 30 + portIndex * 22;
            if (type === 'input') {
                return { x: node.x, y: baseY };
            } else {
                return { x: node.x + width, y: baseY };
            }
        }

        function drawNode(node, isSelected) {
            const width = node.width || 160;
            const height = node.height || 100;
            const x = node.x, y = node.y;

            ctx.fillStyle = node.color || '#3a4a6b';
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 3;
            ctx.beginPath();
            ctx.roundRect(x, y, width, height, 8);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.strokeStyle = isSelected ? '#ffcc00' : '#222230';
            ctx.lineWidth = isSelected ? 3 : 1.5;
            ctx.stroke();

            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${Math.min(16, height/5)}px 'Segoe UI'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.title || node.type, x + width/2, y + height/2);
            ctx.textAlign = 'left';

            node.inputs.forEach((port, idx) => {
                const pos = getPortPosition(node, idx, 'input');
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 5, 0, 2*Math.PI);
                ctx.fillStyle = '#6bd4c8';
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            node.outputs.forEach((port, idx) => {
                const pos = getPortPosition(node, idx, 'output');
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 5, 0, 2*Math.PI);
                ctx.fillStyle = '#f9a87c';
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            if (isSelected) {
                ctx.fillStyle = '#ffcc00';
                ctx.beginPath();
                ctx.moveTo(x + width - 12, y + height - 8);
                ctx.lineTo(x + width - 4, y + height - 8);
                ctx.lineTo(x + width - 8, y + height - 4);
                ctx.fill();
            }
        }

        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.quadraticCurveTo(x + w, y, x + w, y + r);
            this.lineTo(x + w, y + h - r);
            this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            this.lineTo(x + r, y + h);
            this.quadraticCurveTo(x, y + h, x, y + h - r);
            this.lineTo(x, y + r);
            this.quadraticCurveTo(x, y, x + r, y);
            return this;
        };

        canvas.addEventListener('mousedown', (e) => {
            const canvasCoords = getCanvasCoordinates(e);
            const mx = canvasCoords.x, my = canvasCoords.y;

            let hitPort = null;
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                for (let p = 0; p < node.outputs.length; p++) {
                    const pos = getPortPosition(node, p, 'output');
                    if (Math.hypot(mx - pos.x, my - pos.y) < 8) {
                        hitPort = { nodeId: node.id, portIndex: p, type: 'output' };
                        break;
                    }
                }
                if (hitPort) break;
                
                for (let p = 0; p < node.inputs.length; p++) {
                    const pos = getPortPosition(node, p, 'input');
                    if (Math.hypot(mx - pos.x, my - pos.y) < 8) {
                        selectedNode = node.id;
                        selectedEdge = null;
                        drawCanvas();
                        return;
                    }
                }
            }

            if (hitPort && hitPort.type === 'output') {
                isConnecting = true;
                connectionStart = { nodeId: hitPort.nodeId, portIndex: hitPort.portIndex };
                selectedNode = null;
                selectedEdge = null;
                drawCanvas();
                return;
            }

            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                const w = node.width || 160;
                const h = node.height || 100;
                const handleX = node.x + w - 12;
                const handleY = node.y + h - 12;
                if (mx >= handleX && mx <= node.x + w && my >= handleY && my <= node.y + h) {
                    resizeNodeId = node.id;
                    resizeStart.width = w;
                    resizeStart.height = h;
                    resizeStart.mouseX = mx;
                    resizeStart.mouseY = my;
                    selectedNode = node.id;
                    selectedEdge = null;
                    drawCanvas();
                    return;
                }
            }

            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                const w = node.width || 160;
                const h = node.height || 100;
                if (mx >= node.x && mx <= node.x + w && my >= node.y && my <= node.y + h) {
                    if (selectedNode !== node.id) {
                        selectedNode = node.id;
                        selectedEdge = null;
                    }
                    dragNodeId = node.id;
                    dragOffsetX = mx - node.x;
                    dragOffsetY = my - node.y;
                    drawCanvas();
                    return;
                }
            }

            let hitEdgeDist = 15;
            let hitEdgeId = null;
            edges.forEach(edge => {
                const srcNode = nodes.find(n => n.id === edge.sourceNode);
                const tgtNode = nodes.find(n => n.id === edge.targetNode);
                if (!srcNode || !tgtNode) return;
                const sp = getPortPosition(srcNode, edge.sourcePortIndex, 'output');
                const tp = getPortPosition(tgtNode, edge.targetPortIndex, 'input');
                for (let t = 0; t <= 10; t++) {
                    const bt = t / 10;
                    const cx = (1-bt)*(1-bt)*sp.x + 2*(1-bt)*bt*((sp.x+tp.x)/2) + bt*bt*tp.x;
                    const cy = (1-bt)*(1-bt)*sp.y + 2*(1-bt)*bt*((sp.y+tp.y)/2) + bt*bt*tp.y;
                    const d = Math.hypot(mx - cx, my - cy);
                    if (d < hitEdgeDist) {
                        hitEdgeDist = d;
                        hitEdgeId = edge.id;
                    }
                }
            });
            if (hitEdgeId) {
                selectedEdge = hitEdgeId;
                selectedNode = null;
                drawCanvas();
                return;
            }

            if (selectedNode || selectedEdge) {
                selectedNode = null;
                selectedEdge = null;
                drawCanvas();
                return;
            }

            isPanning = true;
            panStart.x = e.clientX;
            panStart.y = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            const canvasCoords = getCanvasCoordinates(e);
            const mx = canvasCoords.x, my = canvasCoords.y;

            if (isPanning) {
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;
                transform.offsetX += dx;
                transform.offsetY += dy;
                panStart.x = e.clientX;
                panStart.y = e.clientY;
                drawCanvas();
                return;
            }

            if (resizeNodeId) {
                const node = nodes.find(n => n.id === resizeNodeId);
                if (node) {
                    const dx = mx - resizeStart.mouseX;
                    const dy = my - resizeStart.mouseY;
                    let newWidth = Math.max(80, resizeStart.width + dx);
                    let newHeight = Math.max(60, resizeStart.height + dy);
                    node.width = newWidth;
                    node.height = newHeight;
                    drawCanvas();
                }
                return;
            }

            if (dragNodeId) {
                const node = nodes.find(n => n.id === dragNodeId);
                if (node) {
                    node.x = mx - dragOffsetX;
                    node.y = my - dragOffsetY;
                    drawCanvas();
                }
                return;
            }

            if (isConnecting) {
                connectionMouseX = mx;
                connectionMouseY = my;
                drawCanvas();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            updatePropertyPanel();
            
            if (isPanning) {
                isPanning = false;
                drawCanvas();
                return;
            }

            if (resizeNodeId) {
                pushHistory();
                resizeNodeId = null;
                drawCanvas();
                return;
            }

            if (dragNodeId) {
                pushHistory();
                dragNodeId = null;
                drawCanvas();
                return;
            }

            if (isConnecting) {
                const canvasCoords = getCanvasCoordinates(e);
                const mx = canvasCoords.x, my = canvasCoords.y;
                let targetPort = null;
                for (let i = nodes.length - 1; i >= 0; i--) {
                    const node = nodes[i];
                    for (let p = 0; p < node.inputs.length; p++) {
                        const pos = getPortPosition(node, p, 'input');
                        if (Math.hypot(mx - pos.x, my - pos.y) < 8) {
                            targetPort = { nodeId: node.id, portIndex: p };
                            break;
                        }
                    }
                    if (targetPort) break;
                }

                if (targetPort && connectionStart) {
                    const sourceNodeId = connectionStart.nodeId;
                    const targetNodeId = targetPort.nodeId;
                    if (sourceNodeId !== targetNodeId) {
                        const alreadyConnected = edges.some(e => e.targetNode === targetNodeId && e.targetPortIndex === targetPort.portIndex);
                        if (!alreadyConnected) {
                            const newEdge = {
                                id: generateEdgeId(),
                                sourceNode: sourceNodeId,
                                sourcePortIndex: connectionStart.portIndex,
                                targetNode: targetNodeId,
                                targetPortIndex: targetPort.portIndex
                            };
                            edges.push(newEdge);
                            pushHistory();
                        }
                    }
                }
                isConnecting = false;
                connectionStart = null;
                drawCanvas();
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const scaleFactor = 1.1;
            const delta = e.deltaY > 0 ? 1/scaleFactor : scaleFactor;
            const oldScale = transform.scale;
            transform.scale *= delta;
            transform.offsetX = mouseX - (mouseX - transform.offsetX) * (transform.scale / oldScale);
            transform.offsetY = mouseY - (mouseY - transform.offsetY) * (transform.scale / oldScale);
            drawCanvas();
        }, { passive: false });

        palette.addEventListener('dragstart', (e) => {
            const nodeType = e.target.dataset.type;
            if (nodeType) {
                e.dataTransfer.setData('text/plain', nodeType);
                e.dataTransfer.effectAllowed = 'copy';
            }
        });

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const nodeType = e.dataTransfer.getData('text/plain');
            if (!nodeType || !nodeTypeDefinitions[nodeType]) return;

            const canvasCoords = getCanvasCoordinates(e);
            const x = canvasCoords.x - 80;
            const y = canvasCoords.y - 40;

            const def = nodeTypeDefinitions[nodeType];
            const newNode = {
                id: generateNodeId(),
                type: nodeType,
                title: def.title,
                x, y,
                width: 160,
                height: 100,
                inputs: def.inputs.map(inp => ({ ...inp })),
                outputs: def.outputs.map(out => ({ ...out })),
                color: def.color,
                properties: { label: def.title, custom: '' }
            };
            nodes.push(newNode);
            pushHistory();
            drawCanvas();
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete') {
                if (selectedEdge) {
                    edges = edges.filter(ed => ed.id !== selectedEdge);
                    selectedEdge = null;
                    pushHistory();
                    drawCanvas();
                } else if (selectedNode) {
                    nodes = nodes.filter(n => n.id !== selectedNode);
                    edges = edges.filter(ed => ed.sourceNode !== selectedNode && ed.targetNode !== selectedNode);
                    selectedNode = null;
                    pushHistory();
                    drawCanvas();
                    updatePropertyPanel();
                }
            }
            if (e.ctrlKey && e.key === 'c' && selectedNode) {
                const node = nodes.find(n => n.id === selectedNode);
                if (node) {
                    const newNode = JSON.parse(JSON.stringify(node));
                    newNode.id = generateNodeId();
                    newNode.x += 30;
                    newNode.y += 30;
                    nodes.push(newNode);
                    pushHistory();
                    drawCanvas();
                }
            }
        });

        function updatePropertyPanel() {
            const propertyPanel = document.querySelector('.property-panel');
            
            if (selectedNode) {
                propertyPanel.classList.remove('hidden');
                
                const node = nodes.find(n => n.id === selectedNode);
                if (!node) return;
                let html = `
                    <div class="property-field">
                        <label>ËäÇÁÇπÂÜÖÂÆπ</label>
                        <input type="text" id="prop-title" value="${node.title || ''}" />
                    </div>
                `;
                propertyDiv.innerHTML = html;
                document.getElementById('prop-title')?.addEventListener('input', (e) => {
                    node.title = e.target.value;
                    if (!node.properties) node.properties = {};
                    node.properties.label = e.target.value;
                    drawCanvas();
                });
                document.getElementById('prop-custom')?.addEventListener('input', (e) => {
                    if (!node.properties) node.properties = {};
                    node.properties.custom = e.target.value;
                });
            } else {
                propertyPanel.classList.add('hidden');
            }
        }

        function saveAsJSON() {
            const data = { nodes, edges };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'workflow.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportSVG() {
            if (nodes.length === 0 && edges.length === 0) {
                alert('ÁîªÂ∏É‰∏∫Á©∫ÔºåÊó†Ê≥ïÂØºÂá∫');
                return;
            }

            const leftWorld = (0 - transform.offsetX) / transform.scale;
            const topWorld = (0 - transform.offsetY) / transform.scale;
            const rightWorld = (canvas.width - transform.offsetX) / transform.scale;
            const bottomWorld = (canvas.height - transform.offsetY) / transform.scale;

            const viewWidth = rightWorld - leftWorld;
            const viewHeight = bottomWorld - topWorld;

            let svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${canvas.width}" height="${canvas.height}" viewBox="${leftWorld} ${topWorld} ${viewWidth} ${viewHeight}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="2" dy="3" stdDeviation="3" flood-color="#000" flood-opacity="0.3"/>
    </filter>
  </defs>

  <g opacity="0.2">
    <defs>
      <pattern id="grid" width="30" height="30" patternUnits="userSpaceOnUse">
        <path d="M 30 0 L 0 0 0 30" fill="none" stroke="#666" stroke-width="1"/>
      </pattern>
    </defs>
    <rect x="${leftWorld}" y="${topWorld}" width="${viewWidth}" height="${viewHeight}" fill="url(#grid)"/>
  </g>

  <g stroke="#9f9fd6" stroke-width="2" fill="none">
`;

            edges.forEach(edge => {
                const sourceNode = nodes.find(n => n.id === edge.sourceNode);
                const targetNode = nodes.find(n => n.id === edge.targetNode);
                if (!sourceNode || !targetNode) return;

                const startPort = getPortPosition(sourceNode, edge.sourcePortIndex, 'output');
                const endPort = getPortPosition(targetNode, edge.targetPortIndex, 'input');
                
                const midX = (startPort.x + endPort.x) / 2;
                svgContent += `    <path d="M ${startPort.x} ${startPort.y} C ${midX} ${startPort.y}, ${midX} ${endPort.y}, ${endPort.x} ${endPort.y}"/>
`;
            });

            svgContent += '  </g>\n  <!-- ËäÇÁÇπ -->\n';

            nodes.forEach(node => {
                const x = node.x;
                const y = node.y;
                const width = node.width || 160;
                const height = node.height || 100;
                const color = node.color || '#3a4a6b';
                
                svgContent += `  <g filter="url(#shadow)">
    <rect x="${x}" y="${y}" width="${width}" height="${height}" rx="8" fill="${color}" stroke="#222230" stroke-width="1.5"/>
    <text x="${x + width/2}" y="${y + height/2}" text-anchor="middle" dominant-baseline="middle" fill="white" font-family="system-ui, sans-serif" font-weight="bold" font-size="${Math.min(16, height/5)}" stroke="black" stroke-width="0.5" paint-order="stroke">${node.title || node.type}</text>
  </g>
`;

                node.inputs.forEach((port, idx) => {
                    const pos = getPortPosition(node, idx, 'input');
                    svgContent += `  <circle cx="${pos.x}" cy="${pos.y}" r="5" fill="#6bd4c8"/>
`;
                });

                node.outputs.forEach((port, idx) => {
                    const pos = getPortPosition(node, idx, 'output');
                    svgContent += `  <circle cx="${pos.x}" cy="${pos.y}" r="5" fill="#f9a87c"/>
`;
                });
            });

            svgContent += '</svg>';

            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'workflow-snapshot.svg';
            a.click();
            URL.revokeObjectURL(url);
        }

        const btnSaveMain = document.getElementById('btn-save-main');
        const btnSaveDropdown = document.getElementById('btn-save-dropdown');
        const saveMenu = document.getElementById('save-menu');
        const btnSaveJson = document.getElementById('btn-save-json');
        const btnSaveSvg = document.getElementById('btn-save-svg');

        btnSaveMain.addEventListener('click', exportSVG);

        btnSaveDropdown.addEventListener('click', (e) => {
            e.stopPropagation();
            saveMenu.style.display = saveMenu.style.display === 'block' ? 'none' : 'block';
        });

        btnSaveJson.addEventListener('click', (e) => {
            e.stopPropagation();
            saveAsJSON();
            saveMenu.style.display = 'none';
        });

        btnSaveSvg.addEventListener('click', (e) => {
            e.stopPropagation();
            exportSVG();
            saveMenu.style.display = 'none';
        });

        document.addEventListener('click', () => {
            saveMenu.style.display = 'none';
        });

        saveMenu.addEventListener('click', (e) => e.stopPropagation());

        document.getElementById('btn-new').addEventListener('click', () => {
            nodes = [];
            edges = [];
            selectedNode = null;
            selectedEdge = null;
            pushHistory();
            updatePropertyPanel();
            drawCanvas();
        });

        document.getElementById('btn-open').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);
                        nodes = data.nodes || [];
                        edges = data.edges || [];
                        nextNodeId = Math.max(...nodes.map(n=>n.id), 1000) + 1;
                        nextEdgeId = Math.max(...edges.map(e=>e.id), 5000) + 1;
                        selectedNode = null;
                        selectedEdge = null;
                        pushHistory();
                        updatePropertyPanel();
                        drawCanvas();
                    } catch (ex) { alert('Êñá‰ª∂Ëß£ÊûêÂ§±Ë¥•'); }
                };
                reader.readAsText(file);
            };
            input.click();
        });

        document.getElementById('btn-undo').addEventListener('click', undo);
        document.getElementById('btn-redo').addEventListener('click', redo);

        document.getElementById('btn-fit').addEventListener('click', () => {
            if (nodes.length === 0) return;
            let minX = Math.min(...nodes.map(n => n.x));
            let minY = Math.min(...nodes.map(n => n.y));
            let maxX = Math.max(...nodes.map(n => n.x + (n.width || 160)));
            let maxY = Math.max(...nodes.map(n => n.y + (n.height || 100)));
            const margin = 50;
            const containerW = canvas.width;
            const containerH = canvas.height;
            const width = maxX - minX;
            const height = maxY - minY;
            if (width <= 0 || height <= 0) return;
            const scale = Math.min(containerW / (width + 2*margin), containerH / (height + 2*margin), 2);
            transform.scale = Math.max(0.2, scale);
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            transform.offsetX = containerW/2 - centerX * transform.scale;
            transform.offsetY = containerH/2 - centerY * transform.scale;
            drawCanvas();
        });

        drawCanvas();
    })();
</script>
</body>
</html>